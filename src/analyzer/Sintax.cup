package analyzer;

import java_cup.runtime.Symbol;

parser code
{:
  private Symbol s;

    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
}

    private TablaSimbolos tablaSimbolos = new TablaSimbolos();

    //Errores
     // Metodo al que se llama en el momento en que ya no es posible una recuperacion de errores
//        public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
//            try {
//                String lexema = s.value.toString();
//                int fila = s.left + 1;
//                int columna = s.right;
//
//                String mensaje = "Error sintáctico irrecuperable, con el símbolo: " + lexema;
//                //System.err.println("Error sintactico inrrecuperable en la linea: " + fila + " y columna: " + columna + ". No se esperaba el componente: " + lexema);
//            } catch(Exception e) {}
//        }
//
//        public void report_error(String message, Object info){
//            if (info instanceof String) {
//                System.out.println(message);
//            }
//            else {
//                if (info instanceof Symbol){
//                    String m = "Error sintático en: " + message;
//                    Symbol s = (Symbol)info;
//                    m += ", con el símbolo: \"" + s.value.toString() + "\"";
//                } else {
//                    System.err.println(message);
//                }
//            }
//        }
//
//        public void ErrorSemantico(Simbolo simbolo) {
//            String msg = "Error en la línea "+ simbolo.getFila() + ", columna "+ simbolo.getColumna() +". Ya existe ";
//            if(simbolo instanceof Variable){
//                msg += "la variable '" + simbolo.getIdentificador() + "' en el ámbito " + simbolo.getScope();
//            }
//        }
//        public void ErrorSemantico(String tipo, String identificador, int fila, int columna){
//                String msg = "Error en la línea "+ (fila+1) + ", columna "+ columna + ". ";
//                switch (tipo){
//                    case "variable":
//                        msg += "La variable '" + identificador + "' no ha sido declarada";
//                        break;
//                }
//                //acá se pondría el metodo para agregar los errores a la UI
//                System.out.println(msg);
//            }
:};

terminal  Int, Float, Bool, Char, Char_literal, String, String_literal, Array, Null, If, Else, While, Switch, Case, Print,
Default, Read, Return, Main, Numeral, Igual, Suma, Resta, Division, Multiplicacion, Modulo, Potencia, Parentesis_apertura,
Parentesis_cierre, Llave_apertura, Llave_cierre, Corchete_apertura, Corchete_cierre, Comillas, Comilla_simple,
Op_Incremento, Op_Decremento, Op_Relacional, Op_Logico, Op_Booleano, Identificador, Numero, Linea, ERROR, Punto, Coma,
Break, Simb_especial, True, False;

non terminal DIGPOS, LETTERUPPER, LETTERLOWER, MARKS, SIMB_ESPECIAL, LETTER, DIG, NUMZER, NUMPOS, NUMNEG, NUM, ID, INT, FLOAT, BOOL,
CHAR, STRING, NULL, ARRAYTIPO, ARRAYPARAM ,TIPO, PARAM, PARAMETRO, NEWARRAY, OPITEM, CREACION, CREAASIG, ASIGNAR,
VARIABLE, PARENTESIS, COMB, COMBRL, OPARITM, OPERANDO, OPARIT, ARITMETICO, OPERANDOARIT, LITERAL, OPUNIARIA,
NEGATIVO, INCR, DECR, EXPRUNARIA, RELACIONAL, RELBOOL, OPREL, OPRL, EXPRBOOL, LOGICO, OPLOG, EXPRLOG, BLOQUE, OPERACION, EXPR,
EXPRVAL, ESTRUCTURA, IF, WHILE, SWITCH, CASE, CASES, OP, LITERALPRINT, FUNCPRINT, PRINT, FUNC, FUNCS, INICIO, MAIN,
COMENTARIO, TIPOASIG, EXPRCOM, CASEOPTION, RETURN, USEFUNC, ARRAY, CREAARRAY, ASIGNARARRAY, VAL_ARRAY;

start with INICIO;

INICIO ::= MAIN | MAIN FUNCS;
MAIN ::= Int Main Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;
MAIN ::= Int Main Parentesis_apertura Parentesis_cierre Llave_apertura Llave_cierre;

BLOQUE ::= EXPR | BLOQUE EXPR;
EXPR ::= VARIABLE | VAL_ARRAY | OPERACION | ESTRUCTURA | RETURN | USEFUNC | FUNCPRINT;
VARIABLE ::= CREACION | CREAASIG | ASIGNAR;
CREACION ::= TIPO Identificador:id_var Numeral // e.g: int x#
    {:
//        TablaSimbolos.tablaSimbolos.add(id_var, id_varleft, id_varright);
        tablaSimbolos.agregarVariable(id_var.toString(), id_varleft, id_varright);
        Variable var = tablaSimbolos.variables.get(0);
        tablaSimbolos.insertar(var);
        System.out.println(tablaSimbolos.getTablaSimbolos());
    :};
CREAASIG ::= TIPO Identificador:_id Igual TIPOASIG Numeral // e.g: int x = 4#
    {:
        //Aca se podría comprobar si el tipo a asignar corresponde con el tipo del id
//        tablaSimbolos.insertar(_id);
    :};
ASIGNAR ::= Identificador:id Igual TIPOASIG Numeral // e.g: x = y#
    {:
        System.out.println(id);
        //Aca se podría comprobar si el tipo a asignar corresponde con el tipo del id
//        tablaSimbolos.insertar(id);
    :};
TIPO ::= Int | Bool | Float | Char | String;
TIPOASIG ::= Numero | Float | String_literal | Char_literal | Identificador | ARRAY | BOOL | OPERACION | USEFUNC;
BOOL ::= True | False;

VAL_ARRAY ::= CREAARRAY | ASIGNARARRAY;
ARRAYTIPO ::= Identificador | Numero;
ARRAY ::= Identificador Corchete_apertura ARRAYTIPO Corchete_cierre;
CREAARRAY ::= ARRAYTIPO Identificador Corchete_apertura ARRAYTIPO Corchete_cierre Numeral;
ASIGNARARRAY ::= Identificador Corchete_apertura ARRAYTIPO Corchete_cierre Igual TIPOASIG Numeral;

OPERACION ::= OP | COMB | Parentesis_apertura OPERACION Parentesis_cierre; // Combinacion de operaciones
OP ::= OPARITM | OPUNIARIA | OPREL | OPLOG;

OPARITM ::= OPERANDOARIT ARITMETICO OPERANDOARIT;
OPERANDOARIT ::= OPERANDO; //| USEFUNC;
OPERANDO ::= Identificador | Numero | Float;
ARITMETICO ::= Suma | Resta | Division | Multiplicacion | Modulo | Potencia;

OPUNIARIA ::= INCR | DECR;
//OPUNIARIA ::= OPUNIARIA Numeral;

INCR ::= OPERANDO Op_Incremento;
INCR ::= Op_Incremento OPERANDO;

DECR ::= OPERANDO Op_Decremento;
DECR ::= Op_Decremento OPERANDO;

OPREL ::= OPERANDO Op_Relacional OPERANDO;

OPLOG ::= EXPRLOG Op_Logico EXPRLOG;
OPLOG ::= Op_Logico EXPRLOG;
EXPRLOG ::= Identificador | BOOL; // | USEFUNC;

COMB ::= OPERACION ARITMETICO OPERANDOARIT;
//COMB ::= OPERACION ARITMETICO OPUNIARIA;  //     ->ERROR
COMB ::= OPERACION Op_Relacional OPERANDO;
//COMB ::= OPERACION Op_Logico EXPRLOG;     //     ->ERROR

ESTRUCTURA ::= IF | WHILE | SWITCH;

IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura Break Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Break Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura BLOQUE Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura Break Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura BLOQUE Break Llave_cierre;

WHILE ::= While Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;

CASEOPTION ::= String_literal | Char_literal | OPERANDO;
SWITCH ::= Switch Parentesis_apertura OPERANDO Parentesis_cierre Llave_apertura CASES Llave_cierre;
CASES ::= CASE | CASES CASE;
CASE ::= Case CASEOPTION Simb_especial BLOQUE;
CASE ::= Case CASEOPTION Simb_especial Break Numeral;
CASE ::= Case CASEOPTION Simb_especial BLOQUE Break Numeral;
CASE ::= Default Simb_especial BLOQUE;
CASE ::= Default Simb_especial Break Numeral;
CASE ::= Default Simb_especial BLOQUE Break Numeral;

FUNCS ::= FUNC | FUNCS FUNC;

FUNCPRINT ::= Print Parentesis_apertura TIPOASIG Parentesis_cierre;

PARAMETRO ::= Coma TIPO Identificador;
PARAM ::= PARAMETRO | PARAM Coma PARAMETRO;

FUNC ::= TIPO Identificador Parentesis_apertura Parentesis_cierre Llave_apertura RETURN Llave_cierre;
FUNC ::= TIPO Identificador Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE RETURN Llave_cierre;
FUNC ::= TIPO Identificador Parentesis_apertura PARAM Parentesis_cierre Llave_apertura BLOQUE RETURN Llave_cierre;
FUNC ::= TIPO Identificador Parentesis_apertura PARAM Parentesis_cierre Llave_apertura RETURN Llave_cierre;

USEFUNC ::= Identificador Parentesis_apertura Parentesis_cierre;
USEFUNC ::= Identificador Parentesis_apertura PARAM Parentesis_cierre;
//USEFUNC ::= USEFUNC Numeral;

RETURN ::= Return TIPOASIG Numeral;

EXPRCOM ::= VARIABLE | OPERACION | ESTRUCTURA | FUNCS | TIPOASIG;
COMENTARIO ::= Division Division EXPRCOM;
COMENTARIO ::= Division Multiplicacion EXPRCOM Multiplicacion Division; //     ->ERROR


/*
DIGPOS ::=  1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
LETTERUPPER ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
LETTERLOWER ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z;
MARKS ::= Simb_especial;
LETTER ::= LETTERUPPER | LETTERLOWER;
DIG ::= 0 | DIGPOS;
NUMZER ::= DIG | NUMZER DIG;
NUMPOS ::= Parentesis_apertura DIGPOS | NUMPOS DIG Parentesis_cierre;
NUMNEG ::= Resta NUMPOS;
NUM ::= NUMPOS | NUMNEG;
ID ::= LETTER | ID LETTER | ID DIG;
INT ::= NUM;
FLOAT ::= NUM Punto NUMZER;
BOOL ::= Bool;
CHAR ::= DIG | LETTER | MARKS | ARITMETICO;
STRING ::= CHAR | STRING CHAR;
ARRAY ::= Corchete_apertura ARRAYPARAM Corchete_cierre;
NULL ::= Null;

ARRAYTIPO ::= INT | CHAR | ID;
ARRAYPARAM ::= ARRAYTIPO;
ARRAYPARAM ::= ARRAYPARAM Coma ARRAYTIPO;

TIPO ::= INT| FLOAT | BOOL | CHAR | STRING;

PARAM ::= TIPO ID;
PARAMETRO ::= PARAM;
PARAMETRO ::= PARAMETRO Coma PARAM;
NEWARRAY ::= ARRAYTIPO ID Corchete_apertura Corchete_cierre Numeral;
NEWARRAY ::= ARRAYTIPO ID  Corchete_apertura Corchete_cierre Igual Llave_apertura ARRAYPARAM Llave_cierre Numeral;
OPITEM ::= ID Corchete_apertura NUMPOS Corchete_cierre Numeral;
OPITEM ::= PARAMETRO;

CREACION ::= TIPO ID Numeral;
CREAASIG ::= TIPO ID Igual EXPRVAL Numeral;
ASIGNAR ::= ID Igual EXPRVAL Numeral;
VARIABLE ::= CREACION | CREAASIG | ASIGNAR;

PARENTESIS ::= Parentesis_apertura OP | COMB | COMBRL | OPERANDO Parentesis_cierre;
ARITMETICO ::= Suma | Resta | Division | Multiplicacion | Modulo | Potencia;
OPARITM ::= OPERANDOARIT ARITMETICO OPERANDOARIT;
OPARITM ::= OPARIT Numeral;
OPERANDOARIT ::= OPERANDO | OPARITM | FUNCS;
OPERANDO ::= ID | LITERAL;
LITERAL ::= INT | FLOAT;
OPUNIARIA ::= NEGATIVO | INCR | DECR;
OPUNIARIA ::= OPUNIARIA Numeral;// unaria es non terminal?
NEGATIVO ::= Resta OPERANDO;
INCR ::= EXPRUNARIA Op_Incremento;
INCR ::= Op_Incremento EXPRUNARIA;
DECR ::= EXPRUNARIA Op_Decremento;
DECR ::= Op_Decremento EXPRUNARIA;
EXPRUNARIA ::= ID | INT | FUNCS;
RELACIONAL ::= Op_Relacional;
RELBOOL ::= Op_Relacional;
OPREL ::= OPERANDO Parentesis_apertura RELACIONAL | RELBOOL Parentesis_cierre OPERANDO;
OPREL ::= EXPRBOOL Parentesis_apertura RELBOOL Parentesis_cierre EXPRBOOL;
OPREL ::= OPREL Numeral;
EXPRBOOL ::= ID | BOOL;
LOGICO ::= Op_Logico;
OPLOG ::= EXPRLOG LOGICO EXPRLOG;
OPLOG ::= Op_Logico EXPRLOG;
OPLOG ::= OPLOG Numeral;
EXPRLOG ::= ID | BOOL |OPLOG | FUNCS;
BLOQUE ::= EXPR;
BLOQUE ::= EXPR BLOQUE;
EXPR ::= VARIABLE | OPERACION | ESTRUCTURA | FUNCS;
EXPRVAL ::= ID	| TIPO | OPERACION | ESTRUCTURA | FUNCS;
OPERACION ::= OP | COMB;
OP ::= OPARITM | OPUNIARIA | OPREL | OPLOG;
COMB ::= OP | ARITMETICO Parentesis_apertura OPERANDOARIT | OPARITM Parentesis_cierre OP;
COMB ::= OP | OPUNIARIA OP;
COMB ::= OP | Parentesis_apertura RELACIONAL | RELBOOL Parentesis_cierre Parentesis_apertura OPERANDO | OPREL Parentesis_cierre OP;
COMB ::= OP | RELBOOL Parentesis_apertura EXPRBOOL | OPREL Parentesis_cierre OP;
COMB ::= OP | LOGICO Parentesis_apertura EXPRLOG | OPLOG Parentesis_cierre OP;
COMB ::= COMB Numeral;
OPRL ::= OPREL | OPLOG;
COMBRL ::= OPRL | OPRL Parentesis_apertura RELACIONAL | RELBOOL Parentesis_cierre Parentesis_apertura OPERANDO | OPREL Parentesis_cierre;
COMBRL ::= OPRL | OPRL RELBOOL Parentesis_apertura EXPRBOOL | OPREL Parentesis_cierre;
COMBRL ::=  OPRL | OPRL LOGICO Parentesis_apertura EXPRLOG | OPLOG Parentesis_cierre;

ESTRUCTURA ::= IF | WHILE | SWITCH;

IF ::= If Parentesis_apertura COMBRL Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;
IF ::= If Parentesis_apertura COMBRL Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura BLOQUE Llave_cierre;

WHILE ::= While Parentesis_apertura COMB Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;

SWITCH ::= Switch Parentesis_apertura OPERANDO Parentesis_cierre Llave_apertura CASE Llave_cierre;
CASE ::= CASE | CASES CASE;
CASES ::= CASE | CASES CASE;
CASE ::= CASE Parentesis_apertura LITERAL Parentesis_cierre Llave_apertura BLOQUE | Parentesis_apertura BLOQUE Break Parentesis_cierre Llave_cierre;
CASE ::= CASE Parentesis_apertura LITERAL Parentesis_cierre Llave_apertura BLOQUE Parentesis_apertura Break | Return Parentesis_cierre Llave_cierre;

LITERALPRINT ::= STRING | CHAR | INT | FLOAT;
FUNCPRINT ::= Print Parentesis_apertura ID | LITERALPRINT Parentesis_cierre Numeral;
FUNCPRINT ::= Print Parentesis_apertura FUNCS | VARIABLE | OPERACION Parentesis_cierre Numeral;

FUNC ::= TIPO ID Parentesis_apertura Parentesis_cierre Llave_apertura Llave_cierre Numeral;
FUNC ::= TIPO ID Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE Return FUNCRETURN Llave_cierre Numeral;
FUNC ::= TIPO ID Parentesis_apertura PARAM Parentesis_cierre Llave_apertura BLOQUE Return FUNCRETURN Llave_cierre Numeral;
FUNC ::= TIPO ID Parentesis_apertura PARAM  Parentesis_cierre Llave_apertura Return FUNCRETURN Llave_cierre Numeral;

FUNCS ::= FUNC | FUNCPRINT;
FUNCS ::= FUNC FUNCS;

FUNCRETURN ::= COMB | Parentesis_apertura INT | FLOAT | CHAR | Null Parentesis_cierre;

INICIO ::= MAIN;
INICIO ::= FUNCS MAIN;
MAIN ::= INT MAIN Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;

COMENTARIO ::= Division Division BLOQUE;
COMENTARIO ::= Multiplicacion Parentesis_apertura INICIO | BLOQUE Parentesis_cierre Multiplicacion;
*/