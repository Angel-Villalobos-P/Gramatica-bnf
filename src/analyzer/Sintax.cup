package analyzer;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    private TablaSimbolos tablaSimbolos = new TablaSimbolos();
    private boolean globalScope = true;
    private TipoDato tipoAsignacion;

    public void syntax_error(Symbol s){
        s = s;
        System.out.println("compiler has detected a syntax error at line " + s.left
                    + " column " + s.right);
    }

    public Symbol getS(){
        return this.s;
    }

    //****************************** Errores ************************
    public void ErrorSemantico(Simbolo simbolo) {
        String msg = "Error en la línea "+ simbolo.getFila() + ", columna "+ simbolo.getColumna() +". Ya existe ";
        if(simbolo instanceof Variable){
            msg += "la variable '" + simbolo.getIdentificador() + "' en el scope: " + simbolo.getScope();
        }
//        else if(simbolo instanceof Funcion){
//            msg += "la funcion o procedimiento '" + simbolo.getIdentificador() + "' con los mismos parámetros";
//        }
        //mostrar error en la UI
        System.out.println(msg);
    }
    public void ErrorSemantico(String identificador, int fila, int columna) {
        String msg = "Error en la línea "+ (fila+1) + ", columna "+ columna +
        ". Tipos de datos no corresponden en la asignación de " + identificador;
        System.out.println(msg);
    }
:};

terminal  Int, Float, Bool, Char, Char_literal, String, String_literal, Array, Null, If, Else, While, Switch, Case, Print,
Default, Read, Return, Main, Numeral, Igual, Suma, Resta, Division, Multiplicacion, Modulo, Potencia, Parentesis_apertura,
Parentesis_cierre, Llave_apertura, Llave_cierre, Corchete_apertura, Corchete_cierre, Comillas, Comilla_simple,
Op_Incremento, Op_Decremento, Op_Relacional, Op_Logico, Op_Booleano, Identificador, Numero, Linea, ERROR, Punto, Coma,
Break, Simb_especial, True, False;

non terminal DIGPOS, LETTERUPPER, LETTERLOWER, MARKS, SIMB_ESPECIAL, LETTER, DIG, NUMZER, NUMPOS, NUMNEG, NUM, ID, INT, FLOAT, BOOL,
CHAR, STRING, NULL, ARRAYTIPO, ARRAYPARAM ,TIPO, PARAM, PARAMETRO, NEWARRAY, OPITEM, CREACION, CREAASIG, ASIGNAR,
VARIABLE, PARENTESIS, COMB, COMBRL, OPARITM, OPERANDO, OPARIT, ARITMETICO, OPERANDOARIT, LITERAL, OPUNIARIA,
NEGATIVO, INCR, DECR, EXPRUNARIA, RELACIONAL, RELBOOL, OPREL, OPRL, EXPRBOOL, LOGICO, OPLOG, EXPRLOG, BLOQUE, OPERACION, EXPR,
EXPRVAL, ESTRUCTURA, IF, WHILE, SWITCH, CASE, CASES, OP, LITERALPRINT, FUNCPRINT, PRINT, FUNC, FUNCS, INICIO, MAIN,
COMENTARIO, TIPOASIG, EXPRCOM, CASEOPTION, RETURN, USEFUNC, ARRAY, CREAARRAY, ASIGNARARRAY, VAL_ARRAY;

start with INICIO;

INICIO ::= MAIN | MAIN FUNCS;
MAIN ::= Int Main Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;
MAIN ::= Int Main Parentesis_apertura Parentesis_cierre Llave_apertura Llave_cierre;

BLOQUE ::= EXPR | BLOQUE EXPR;
EXPR ::= VARIABLE | VAL_ARRAY | OPERACION | ESTRUCTURA | RETURN | USEFUNC | FUNCPRINT;
VARIABLE ::= CREACION | CREAASIG | ASIGNAR;
CREACION ::= TIPO Identificador:id Numeral // e.g: int x#
    {:
//        tablaSimbolos.agregarVariable(id.toString(), idleft, idright); //agrega la variable
        if (globalScope) {//setea el scope a globql
            if (!tablaSimbolos.existeVariable(id.toString(), "Global")){
                tablaSimbolos.agregarVariable(id.toString(), idleft, idright); //agrega la variable
            }

            for (int i = 0; i < tablaSimbolos.variables.size(); i++) {
                Variable var = tablaSimbolos.variables.get(i);
                var.setScope("Global");
                if (tablaSimbolos.getTablaSimbolosSize() > 1) {
                    if (!tablaSimbolos.existeSimbolo(var)) {
                        tablaSimbolos.insertar(var);
                    } else {
                        ErrorSemantico(var);
                    }
                } else {
                    tablaSimbolos.insertar(var);
                }
            }
        }
    :};
CREAASIG ::= TIPO Identificador:id Igual TIPOASIG:_tipoAsign Numeral // e.g: int x = 4#
    {:
        //por acá debe hacer la comprobación de tipos
        //...
        if (globalScope) {//setea el scope a globql
            if (!tablaSimbolos.existeVariable(id.toString(), "Global")){
                tablaSimbolos.agregarVariable(id.toString(), idleft, idright); //agrega la variable
            }

            for (int i = 0; i < tablaSimbolos.variables.size(); i++) {
                Variable var = tablaSimbolos.variables.get(i);
                var.setScope("Global");
                if (tablaSimbolos.getTablaSimbolosSize() > 1) {
                    if (!tablaSimbolos.existeSimbolo(var)) {
                        tablaSimbolos.insertar(var);
                    } else {
                        ErrorSemantico(var);
                    }
                } else {
                    tablaSimbolos.insertar(var);
                }
            }
            if (!tablaSimbolos.verificarTipo(id.toString(), "Global", tipoAsignacion)){
                System.out.println("Operación inválida, tipo de datos diferentes");
                ErrorSemantico(id.toString(), idleft, idright);
                return null;
            }
        }
    :} | error:e {: System.out.println(e.toString()); :};
//ASIGNAR ::= Identificador:id Igual Numero:_tipoAsig Numeral
//{:
//System.out.println(_tipoAsig.toString());
//:};
ASIGNAR ::= Identificador:id Igual TIPOASIG:_tipoAsig Numeral // e.g: x = y#
    {:
//        Variable aux = tablaSimbolos.getVariable(id.toString(), "Global");
//        System.out.println(aux.getIdentificador() + " - " + aux.getTipoDato() + " - " + aux.getScope());
//        System.out.println(_tipoAsig.toString());
    :};
TIPO ::= Int:_int
    {:
        RESULT = new Symbol(-1, _int.toString());
        tablaSimbolos.agregarTipoDato(TipoDato.Int);
    :}
    | Bool:_bool
    {:
            RESULT = new Symbol(-1, _bool.toString());
            tablaSimbolos.agregarTipoDato(TipoDato.Bool);
     :}
    | Float:_float
    {:
            RESULT = new Symbol(-1, _float.toString());
            tablaSimbolos.agregarTipoDato(TipoDato.Float);
    :}
    | Char:_char
    {:
            RESULT = new Symbol(-1, _char.toString());
            tablaSimbolos.agregarTipoDato(TipoDato.Char);
    :}
    | String:_string
    {:
            RESULT = new Symbol(-1, _string.toString());
            tablaSimbolos.agregarTipoDato(TipoDato.String);
    :}
    ;
TIPOASIG ::= Numero:num
    {:
        tipoAsignacion = TipoDato.Int;
        System.out.println(num + " <--- numero");
        System.out.println(tipoAsignacion + " <--- tipo de asig");
    :}
 | Float:_float
     {:
         System.out.println(_float + " <--- float");
     :}
  | String_literal | Char_literal | Identificador | ARRAY | BOOL | OPERACION | USEFUNC;
//TIPOASIG ::= Numero | Float | String_literal | Char_literal | Identificador;// | ARRAY | BOOL | OPERACION | USEFUNC;
BOOL ::= True | False;

VAL_ARRAY ::= CREAARRAY | ASIGNARARRAY;
ARRAYTIPO ::= Identificador | Numero;
ARRAY ::= Identificador Corchete_apertura ARRAYTIPO Corchete_cierre;
CREAARRAY ::= ARRAYTIPO Identificador Corchete_apertura ARRAYTIPO Corchete_cierre Numeral;
ASIGNARARRAY ::= Identificador Corchete_apertura ARRAYTIPO Corchete_cierre Igual TIPOASIG Numeral;

OPERACION ::= OP | COMB | Parentesis_apertura OPERACION Parentesis_cierre; // Combinacion de operaciones
OP ::= OPARITM | OPUNIARIA | OPREL | OPLOG;

OPARITM ::= OPERANDOARIT ARITMETICO OPERANDOARIT;
OPERANDOARIT ::= OPERANDO; //| USEFUNC;
OPERANDO ::= Identificador | Numero | Float;
ARITMETICO ::= Suma | Resta | Division | Multiplicacion | Modulo | Potencia;

OPUNIARIA ::= INCR | DECR;
//OPUNIARIA ::= OPUNIARIA Numeral;

INCR ::= OPERANDO Op_Incremento;
INCR ::= Op_Incremento OPERANDO;

DECR ::= OPERANDO Op_Decremento;
DECR ::= Op_Decremento OPERANDO;

OPREL ::= OPERANDO Op_Relacional OPERANDO;

OPLOG ::= EXPRLOG Op_Logico EXPRLOG;
OPLOG ::= Op_Logico EXPRLOG;
EXPRLOG ::= Identificador | BOOL; // | USEFUNC;

COMB ::= OPERACION ARITMETICO OPERANDOARIT;
//COMB ::= OPERACION ARITMETICO OPUNIARIA;  //     ->ERROR
COMB ::= OPERACION Op_Relacional OPERANDO;
//COMB ::= OPERACION Op_Logico EXPRLOG;     //     ->ERROR

ESTRUCTURA ::= IF | WHILE | SWITCH;

IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura Break Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Break Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura BLOQUE Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura Break Llave_cierre;
IF ::= If Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura BLOQUE Break Llave_cierre;

WHILE ::= While Parentesis_apertura OPERACION Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;

CASEOPTION ::= String_literal | Char_literal | OPERANDO;
SWITCH ::= Switch Parentesis_apertura OPERANDO Parentesis_cierre Llave_apertura CASES Llave_cierre;
CASES ::= CASE | CASES CASE;
CASE ::= Case CASEOPTION Simb_especial BLOQUE;
CASE ::= Case CASEOPTION Simb_especial Break Numeral;
CASE ::= Case CASEOPTION Simb_especial BLOQUE Break Numeral;
CASE ::= Default Simb_especial BLOQUE;
CASE ::= Default Simb_especial Break Numeral;
CASE ::= Default Simb_especial BLOQUE Break Numeral;

FUNCS ::= FUNC | FUNCS FUNC;

FUNCPRINT ::= Print Parentesis_apertura TIPOASIG Parentesis_cierre;

PARAMETRO ::= Coma TIPO Identificador;
PARAM ::= PARAMETRO | PARAM Coma PARAMETRO;

FUNC ::= TIPO Identificador Parentesis_apertura Parentesis_cierre Llave_apertura RETURN Llave_cierre;
FUNC ::= TIPO Identificador Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE RETURN Llave_cierre;
FUNC ::= TIPO Identificador Parentesis_apertura PARAM Parentesis_cierre Llave_apertura BLOQUE RETURN Llave_cierre;
FUNC ::= TIPO Identificador Parentesis_apertura PARAM Parentesis_cierre Llave_apertura RETURN Llave_cierre;

USEFUNC ::= Identificador Parentesis_apertura Parentesis_cierre;
USEFUNC ::= Identificador Parentesis_apertura PARAM Parentesis_cierre;
//USEFUNC ::= USEFUNC Numeral;

RETURN ::= Return TIPOASIG Numeral;

EXPRCOM ::= VARIABLE | OPERACION | ESTRUCTURA | FUNCS | TIPOASIG;
COMENTARIO ::= Division Division EXPRCOM;
COMENTARIO ::= Division Multiplicacion EXPRCOM Multiplicacion Division; //     ->ERROR


/*
DIGPOS ::=  1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
LETTERUPPER ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
LETTERLOWER ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z;
MARKS ::= Simb_especial;
LETTER ::= LETTERUPPER | LETTERLOWER;
DIG ::= 0 | DIGPOS;
NUMZER ::= DIG | NUMZER DIG;
NUMPOS ::= Parentesis_apertura DIGPOS | NUMPOS DIG Parentesis_cierre;
NUMNEG ::= Resta NUMPOS;
NUM ::= NUMPOS | NUMNEG;
ID ::= LETTER | ID LETTER | ID DIG;
INT ::= NUM;
FLOAT ::= NUM Punto NUMZER;
BOOL ::= Bool;
CHAR ::= DIG | LETTER | MARKS | ARITMETICO;
STRING ::= CHAR | STRING CHAR;
ARRAY ::= Corchete_apertura ARRAYPARAM Corchete_cierre;
NULL ::= Null;

ARRAYTIPO ::= INT | CHAR | ID;
ARRAYPARAM ::= ARRAYTIPO;
ARRAYPARAM ::= ARRAYPARAM Coma ARRAYTIPO;

TIPO ::= INT| FLOAT | BOOL | CHAR | STRING;

PARAM ::= TIPO ID;
PARAMETRO ::= PARAM;
PARAMETRO ::= PARAMETRO Coma PARAM;
NEWARRAY ::= ARRAYTIPO ID Corchete_apertura Corchete_cierre Numeral;
NEWARRAY ::= ARRAYTIPO ID  Corchete_apertura Corchete_cierre Igual Llave_apertura ARRAYPARAM Llave_cierre Numeral;
OPITEM ::= ID Corchete_apertura NUMPOS Corchete_cierre Numeral;
OPITEM ::= PARAMETRO;

CREACION ::= TIPO ID Numeral;
CREAASIG ::= TIPO ID Igual EXPRVAL Numeral;
ASIGNAR ::= ID Igual EXPRVAL Numeral;
VARIABLE ::= CREACION | CREAASIG | ASIGNAR;

PARENTESIS ::= Parentesis_apertura OP | COMB | COMBRL | OPERANDO Parentesis_cierre;
ARITMETICO ::= Suma | Resta | Division | Multiplicacion | Modulo | Potencia;
OPARITM ::= OPERANDOARIT ARITMETICO OPERANDOARIT;
OPARITM ::= OPARIT Numeral;
OPERANDOARIT ::= OPERANDO | OPARITM | FUNCS;
OPERANDO ::= ID | LITERAL;
LITERAL ::= INT | FLOAT;
OPUNIARIA ::= NEGATIVO | INCR | DECR;
OPUNIARIA ::= OPUNIARIA Numeral;// unaria es non terminal?
NEGATIVO ::= Resta OPERANDO;
INCR ::= EXPRUNARIA Op_Incremento;
INCR ::= Op_Incremento EXPRUNARIA;
DECR ::= EXPRUNARIA Op_Decremento;
DECR ::= Op_Decremento EXPRUNARIA;
EXPRUNARIA ::= ID | INT | FUNCS;
RELACIONAL ::= Op_Relacional;
RELBOOL ::= Op_Relacional;
OPREL ::= OPERANDO Parentesis_apertura RELACIONAL | RELBOOL Parentesis_cierre OPERANDO;
OPREL ::= EXPRBOOL Parentesis_apertura RELBOOL Parentesis_cierre EXPRBOOL;
OPREL ::= OPREL Numeral;
EXPRBOOL ::= ID | BOOL;
LOGICO ::= Op_Logico;
OPLOG ::= EXPRLOG LOGICO EXPRLOG;
OPLOG ::= Op_Logico EXPRLOG;
OPLOG ::= OPLOG Numeral;
EXPRLOG ::= ID | BOOL |OPLOG | FUNCS;
BLOQUE ::= EXPR;
BLOQUE ::= EXPR BLOQUE;
EXPR ::= VARIABLE | OPERACION | ESTRUCTURA | FUNCS;
EXPRVAL ::= ID	| TIPO | OPERACION | ESTRUCTURA | FUNCS;
OPERACION ::= OP | COMB;
OP ::= OPARITM | OPUNIARIA | OPREL | OPLOG;
COMB ::= OP | ARITMETICO Parentesis_apertura OPERANDOARIT | OPARITM Parentesis_cierre OP;
COMB ::= OP | OPUNIARIA OP;
COMB ::= OP | Parentesis_apertura RELACIONAL | RELBOOL Parentesis_cierre Parentesis_apertura OPERANDO | OPREL Parentesis_cierre OP;
COMB ::= OP | RELBOOL Parentesis_apertura EXPRBOOL | OPREL Parentesis_cierre OP;
COMB ::= OP | LOGICO Parentesis_apertura EXPRLOG | OPLOG Parentesis_cierre OP;
COMB ::= COMB Numeral;
OPRL ::= OPREL | OPLOG;
COMBRL ::= OPRL | OPRL Parentesis_apertura RELACIONAL | RELBOOL Parentesis_cierre Parentesis_apertura OPERANDO | OPREL Parentesis_cierre;
COMBRL ::= OPRL | OPRL RELBOOL Parentesis_apertura EXPRBOOL | OPREL Parentesis_cierre;
COMBRL ::=  OPRL | OPRL LOGICO Parentesis_apertura EXPRLOG | OPLOG Parentesis_cierre;

ESTRUCTURA ::= IF | WHILE | SWITCH;

IF ::= If Parentesis_apertura COMBRL Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;
IF ::= If Parentesis_apertura COMBRL Parentesis_cierre Llave_apertura BLOQUE Llave_cierre Else Llave_apertura BLOQUE Llave_cierre;

WHILE ::= While Parentesis_apertura COMB Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;

SWITCH ::= Switch Parentesis_apertura OPERANDO Parentesis_cierre Llave_apertura CASE Llave_cierre;
CASE ::= CASE | CASES CASE;
CASES ::= CASE | CASES CASE;
CASE ::= CASE Parentesis_apertura LITERAL Parentesis_cierre Llave_apertura BLOQUE | Parentesis_apertura BLOQUE Break Parentesis_cierre Llave_cierre;
CASE ::= CASE Parentesis_apertura LITERAL Parentesis_cierre Llave_apertura BLOQUE Parentesis_apertura Break | Return Parentesis_cierre Llave_cierre;

LITERALPRINT ::= STRING | CHAR | INT | FLOAT;
FUNCPRINT ::= Print Parentesis_apertura ID | LITERALPRINT Parentesis_cierre Numeral;
FUNCPRINT ::= Print Parentesis_apertura FUNCS | VARIABLE | OPERACION Parentesis_cierre Numeral;

FUNC ::= TIPO ID Parentesis_apertura Parentesis_cierre Llave_apertura Llave_cierre Numeral;
FUNC ::= TIPO ID Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE Return FUNCRETURN Llave_cierre Numeral;
FUNC ::= TIPO ID Parentesis_apertura PARAM Parentesis_cierre Llave_apertura BLOQUE Return FUNCRETURN Llave_cierre Numeral;
FUNC ::= TIPO ID Parentesis_apertura PARAM  Parentesis_cierre Llave_apertura Return FUNCRETURN Llave_cierre Numeral;

FUNCS ::= FUNC | FUNCPRINT;
FUNCS ::= FUNC FUNCS;

FUNCRETURN ::= COMB | Parentesis_apertura INT | FLOAT | CHAR | Null Parentesis_cierre;

INICIO ::= MAIN;
INICIO ::= FUNCS MAIN;
MAIN ::= INT MAIN Parentesis_apertura Parentesis_cierre Llave_apertura BLOQUE Llave_cierre;

COMENTARIO ::= Division Division BLOQUE;
COMENTARIO ::= Multiplicacion Parentesis_apertura INICIO | BLOQUE Parentesis_cierre Multiplicacion;
*/